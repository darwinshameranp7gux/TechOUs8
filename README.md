# Data-Structures

A repository of Data Structures and all the programs in different languages.

## CONTRIBUTION

For your contribution follow our [guidelines](CONTRIBUTING.md)

## ARRAYS

* 1D Arrays
  * C
    * [Simple](ARRAYS/C/1DArrays.c)
    * [Using heap memory](ARRAYS/C/dynamicarray.c)
  * [C++](ARRAYS/C++/1darrays.cpp)
  * [JAVA](ARRAYS/JAVA/oneDarray.java)
* 2D Arrays
  * C
    * [Simple](ARRAYS/C/2DArrays.c)
    * [Using heap memory](ARRAYS/C/dynamic2d.c)
  * [C++](ARRAYS/C++/2darrays.cpp)
  * [JAVA](ARRAYS/JAVA/twoDarray.java)
* 3D Arrays
  * C
    * [Simple](ARRAYS/C/3DArrays.c)
    * [Using heap memory](ARRRAYS/C/dynamic3d.c)
  * [C++](ARRAYS/C++/3darrays.cpp)
  * [JAVA](ARRAYS/JAVA/threeDarray.java)
* 4D Arrays
  * [C](ARRAYS/C/4DArrays.c)
  * [C++](ARRAYS/C++/4darrays.cpp)
  * [JAVA](ARRAYS/JAVA/fourDarray.java)
* INBUILT
  * [Arrays class in JAVA](ARRAYS/JAVA/arrays.java)
* MISC
  * JAGGED
    * [C](ARRAYS/C/MISC/jaggedarray.c)

## STRING

* [C](STRING/C/Strings.c)
* [C++](STRING/C++/Strings.cpp)
* [JAVA](STRING/JAVA/Strings.java)

## LISTS

* SINGLE
  * [C](LISTS/SINGLE/C/Main.c)
  * [C++](LISTS/SINGLE/Cpp/Main.cpp)
    * [INSERT AT HEAD](LISTS/SINGLE/Cpp/Insert_at_Head.cpp)
    * [INSERT AT TAIL](LISTS/SINGLE/Cpp/Insert_at_Tail.cpp)
  * [JAVA](LISTS/SINGLE/JAVA/Main.java)
* DOUBLE
  * [C](LISTS/DOUBLE/C/Main.c)
  * [JAVA](LISTS/DOUBLE/JAVA/Main.java)
* CIRCULAR
* INBUILT LISTS
  * LINKED LIST
  * ARRAYLIST
    * [JAVA](LISTS/INBUILT/ARRAYLIST/JAVA/arrayList.java)
  * VECTORS
    * [C++](LISTS/INBUILT/VECTORS/C++/Main.cpp)
    * [JAVA](LISTS/INBUILT/VECTORS/JAVA/vectors.java)
* MISC
  * Find the nth node from the end in Single Linked List
    * JAVA
      * APPROACH 1: [Compute the size while adding](LISTS/MISC/Nth-node-from-end/JAVA/Approach1.java)
      * APPROACH 2: [Using two current pointers](LISTS/MISC/Nth-node-from-end/JAVA/Approach2.java)
      * APPROACH 3: [Using hashtable](LISTS/MISC/Nth-node-from-end/JAVA/Approach3.java)
      * APPROACH 4: [Using Hashtable while adding](LISTS/MISC/Nth-node-from-end/JAVA/Approach4.java)
      * APPROACH 5: [Finding node in one scan](LISTS/MISC/Nth-node-from-end/JAVA/Approach5.java)
      * APPROACH 6: [Using recursion](LISTS/MISC/Nth-node-from-end/JAVA/Approach6.java)

## STACKS

* FIXED ARRAY STACK
  * [JAVA](STACKS/JAVA/ArrayStack.java)
* DYNAMIC ARRAY STACK
  * [C++](STACKS/Cpp/basicPushPop.cpp)
* LINKED STACK
  * [JAVA](STACKS/JAVA/LINKED-STACK/LinkedStack.java)
* INBUILT
* MISC
  * C++
    * [Brackets are balanced or not](STACKS/Cpp/balancedParanthesis.cpp)
    * [Evaluation of expression](STACKS/Cpp/evaluationofExpressions.cpp)
    * [Infix to postfix](STACKS/Cpp/infixTopostfix.cpp)
    * [Finding the minimum element](STACKS/Cpp/minimum_element_using_stack.cpp)
    * [Reverse a stack](STACKS/Cpp/reverseStack.cpp)
  * Python
    * [Brackets are balanced or not](STACKS/Python/balancedParanthesis.py)
    * [Basic Push Pop](STACKS/Python/basicPushPop.py)
    * [Infix to postfix](STACKS/Python/infixToPostfix.py)
    * [Infix to prefix](STACKS/Python/infixToPrefix.py)
    * [Postfix Evaluation](STACKS/Python/postfixEvaluation.py)
    * [Prefix Evaluation](STACKS/Python/prefixEvaluation.py)
    * [Reverse a stack](STACKS/Python/reverseStack.py)

## QUEUES

## TREES

### BINARY TREES

* TRAVERSALS
  * DEPTH FIRST SEARCH
    * INORDER
      * C
        * ITERATIVE
        * [RECURSIVE](TREES/BINARY-TREE/C/inordertraversal.c)
      * C++
        * [RECURSIVE](TREES/BINARY-TREE/Cpp/traversalUsing_B_Tree.cpp)
      * JAVA
        * [ITERATIVE](TREES/BINARY-TREE/JAVA/IterativeInorder.java)
        * [RECURSIVE](TREES/BINARY-TREE/JAVA/Inorder.java)
    * PREORDER
      * C++
        * [RECURSIVE](TREES/BINARY-TREE/Cpp/traversalUsing_B_Tree.cpp)
      * JAVA
        * [ITERATIVE](TREES/BINARY-TREE/JAVA/IterativePreorder.java)
        * [RECURSIVE](TREES/BINARY-TREE/JAVA/Preorder.java)
    * POSTORDER
      * C++
        * [RECURSIVE](TREES/BINARY-TREE/Cpp/traversalUsing_B_Tree.cpp)
      * JAVA
        * [ITERATIVE](TREES/BINARY-TREE/JAVA/IterativePostorder.java)
        * [RECURSIVE](TREES/BINARY-TREE/JAVA/Postorder.java)
  * BREADTH FIRST SEARCH
    * LEVEL ORDER
      * [C](TREES/BINARY-TREE/C/printLevelorder.c)
      * [C++](TREES/BINARY-TREE/Cpp/printLevelOrder.cpp)
      * [JAVA](TREES/BINARY-TREE/JAVA/LevelOrder.java)
* MISC
  * **Construct Tree using Inorder and Preorder**
    * [C](TREES/BINARY-TREE/C/constructTreeInorder.c)
  * **Construct Tree with inorder and postorder**
    * [C++](TREES/BINARY-TREE/Cpp/Construct_Tree_In_Post.cpp)
  * **Find right nodes**
    * [C++](TREES/BINARY-TREE/Cpp/printRightNodes.cpp)
  * **Print odd level nodes**
    * [C++](TREES/BINARY-TREE/Cpp/printOddEvenNodes_Tree.cpp)
  * **Count leaf and non leaf nodes**
    * [C++](TREES/BINARY-TREE/Cpp/findLeafAndNonLeaf.cpp)
  * **Find the height of the tree**
    * [C++](TREES/BINARY-TREE/Cpp/findHeightOfTree.cpp)
  * **Construct Mirror Tree**
    * [C++](TREES/BINARY-TREE/Cpp/ConstructMirrorTree.cpp)

## GRAPHS

## LICENSE

[Apache License](LICENSE)

### NOTE : Dont forget to pull before pushing your commits otherwise it will create merge conflicts

                                            ALL RIGHTS RESERVED:

                                            TradeMark : TechOus

                                            Admins: 1. Nidhi Mittal
                                                    2. Aniket Batabyal
